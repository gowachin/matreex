---
title: "Running multi species deterministic simulations"
output: 
    github_document:
    rmarkdown::html_vignette:
vignette: >
  %\VignetteIndexEntry{Running multi species deterministic simulations}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>",
    fig.width = 7, # default vignette figure size is too small
    fig.height = 5
)
```

```{r setup}
library(treeforce)
```

# Introduction

Simulation run on the Forest class object, that contains all elements. It's composed of *n* species. Each species is defined by multiples functions :

-   init_pop is the function to initiate the population at time 1.
-   recruit_fun is the function that depend on the total basal area. 
-   harvest_fun is the function that return the harvested population that should be subtracted to the population at time t.
-   IPM is the list of integrated matrices for several basal area.

# Loading previous work IPM

Functions are defined to load the previous IPM saved as *.Rds*. The files must located in specific directory format which is :

**`path/output/species/IPM_Clim_X.Rds`**

Once the files are in place, the code below allow to create the species of interest. One last argument is *replicat* which select one of the 100 simulations of previous work. **A mean IPM should replace this later**.

Default functions of initialization and harvest are used. You can write your own functions as long as they use the same arguments. Try to write function that don't initialize negative populations.

Example data set is a cropped IPM with a mesh of length 30 with BA from 1 to 10.

```{r, loading species Yggdrasil}
spe <- "Yggdrasil" # Example dataset given with the package
# Warning, loading an old IPM takes around 10s
Yggdrasil <- old_ipm2species(
    spe, climatic = 1, replicat = 1,
    path = system.file("extdata", package = "treeforce", mustWork = TRUE),
)
def_init
```

A forest is just a list of the species. **Later it will also require harvest rules with target BA and species**

```{r, Forest}
Forest <- forest(list(Yggdrasil))
```

# Simulation

Simulations are done with the function `sim_deter_forest`. Such simulations are deterministic once the initial population is defined. As the species *Yggdrasil* we have defined use random generation for the initial population, we will use a seed before each simulation.

## Single species

A simulation is mostly defined by the time limitation (*tlim*) and an equilibrium time (*equil_time*). 

```{r, single sp sim}
set.seed(42)
res <- sim_deter_forest(Forest, tlim = 30, equil_time = 1e3,
                        correction = "cut", equil_dist = 50,
                        verbose = TRUE)
```

The output is a single table with time in column and different variables in rows. The variables are given at each time point plus equilibrium state. 
They are defined below :

- Distribution in the mesh of the species
- Basal Area
- Sum of the distribution
- Distribution of harvest
- Sum of harvest

```{r, single_print}
m <- length(Forest$species$Yggdrasil$IPM$mesh)
res[c(1:2, m:(m+3), (2 *m + 2):(2 *m + 3)), c(1:3,30:31)]
times <- as.numeric(sub("t", "", colnames(res)))

plot(times, res[grepl("BA",rownames(res)),], 
     type = "b", ylab = "BA", xlab = "time", cex = 0.1)
```

## Multiple species 

Below, I create a mock second species to illustrate how to combine species in simulation and recreate the same plot for total basal area.

We expect the same equilibrium result (minus the initial population random effect), since the species dynamics are similar. 

```{r, two sp sim}
Ents <- Yggdrasil
Ents$info["species"] <- "Ents"

Forest2 <- forest(species = list(Yggdrasil = Yggdrasil,
                                 Ents = Ents))

set.seed(42)
res <- sim_deter_forest(Forest2, tlim = 30, equil_time = 1e3,
                        correction = "cut", equil_dist = 50,
                        verbose = TRUE)
```

The result is the same table with each species tables grouped one under the other. Since the species names is pasted with the variable name in row names, one can extract variables of interest.

```{r, two_print, echo = FALSE}
m2 <- m *2 + 3
res[c(1:2, m:(m+3), (2 *m + 2):m2, 
      (m2 +1):(m2 +2), (m2 + m):(m2 + m +3), (m2 + 2 *m + 2):(2*m2)),
    c(1:2,30:31)]

times <- as.numeric(sub("t", "", colnames(res)))
value <- colSums(res[grepl("BA",rownames(res)),])
plot(times, value, type = "b", ylab = "Total BA", xlab = "time", 
     cex = 0.1, ylim = c(1, max(value) * 1.05))
points(times, res[grepl("Ygg.*BA",rownames(res)),], 
       type = "b", ylab = "Total BA", xlab = "time", cex = 0.1, col = "darkblue")
points(times, res[grepl("Ent.*BA",rownames(res)),], 
       type = "b", ylab = "Total BA", xlab = "time", cex = 0.1, col = "darkgreen")
```

## Changing harvesting rules.

Once a species is defined, you can modify it and say use a different harvest function. For example, the default function apply a constant harvesting rate of 0.6 percent per year.

```{r}
Yggdrasil$harvest_fun
```

We can use another function that set an Uneven harvest a specified intervals. To modify this interval, we need to edit the harvest rules (*harv_rules*) when creating a Forest

```{r}
Yggdrasil$harvest_fun <- Uneven_harv

# Because this example is a reduced mesh, I need to modify the harv_lim of the species
Yggdrasil$harv_lim <- c(dth = 95, dha = 110, hmax = 1)
Forest_harv <- forest(list(Yggdrasil),
                      harv_rules = c(Pmax = 1, dBAmin = 0.2, freq = 10, alpha = 1))
targetBA <- 2
set.seed(42)
res <- sim_deter_forest(Forest_harv, tlim = 60, 
                        equil_time = 60, equil_dist = 5,
                        correction = "cut", targetBA = targetBA,
                        verbose = TRUE)
```


```{r, harv_print, echo = FALSE}
m <- length(Forest$species$Yggdrasil$IPM$mesh)
res[c(1:2, m:(m+3), (2 *m + 2):(2 *m + 3)), c(1:3,30:31)]
times <- as.numeric(sub("t", "", colnames(res)))

plot(times, res[grepl("BA",rownames(res)),], 
     type = "b", ylab = "BA", xlab = "time", cex = 0.1)
abline(h = targetBA, col = "darkgreen")
plot(times, res[grepl("H",rownames(res)),], 
     type = "b", ylab = "H", xlab = "time", cex = 0.1)
```

Here we observe that harvest is not enough to reach targetBA. This could be explained by a restriction in tree size target.

```{r, echo = FALSE}
m <- Forest_harv$species$Yggdrasil$IPM$mesh
plot(m, res[grepl("m",rownames(res)),59], 
     type = "b", ylab = "X", xlab = "size", cex = 0.1, col = "darkblue",
)
points(m, res[grepl("m",rownames(res)),60], 
       type = "b", cex = 0.1, col = "darkgreen")
legend("bottomleft", c("before (t59)", "after (t60)"), text.col = c("darkblue", "darkgreen"))
```

The uneven harvest is possible with multiple species. Multiple parameters will scale the effect of harvest :

- Pmax, the maximum percentage of harvest possible
- freq, the frequency of harvest
- alpha, which will modulate the distribution of the cut on the species according to their abundances. When alpha = 1, the species are cut according to their abundance, which tends to balance the ratio of species. Alpha > 1 will overcut the most present species, which can lead to unstable equilibrium. Alpha < 1 will undercut the abundant species as well.

```{r, two sp harv sim}
Ents <- Yggdrasil
Ents$info["species"] <- "Ents"

Forest_harv2 <- forest(species = list(Yggdrasil = Yggdrasil,
                                      Ents = Ents),
                       harv_rules = c(Pmax = 1, dBAmin = 0.2, freq = 5, alpha = 1))

set.seed(42)
res <- sim_deter_forest(Forest_harv2, tlim = 60, 
                        equil_time = 60, equil_dist = 5,
                        correction = "cut", targetBA = targetBA,
                        verbose = TRUE)
```


```{r, harv_two_print, echo = FALSE}
times <- as.numeric(sub("t", "", colnames(res)))
value <- colSums(res[grepl("BA",rownames(res)),])
plot(times, value, type = "b", ylab = "Total BA", xlab = "time", 
     cex = 0.1, ylim = c(1, max(value) * 1.05))
points(times, res[grepl("Ygg.*BA",rownames(res)),], 
       type = "b", ylab = "Total BA", xlab = "time", cex = 0.1, col = "darkblue")
points(times, res[grepl("Ent.*BA",rownames(res)),], 
       type = "b", ylab = "Total BA", xlab = "time", cex = 0.1, col = "darkgreen")
abline(h = targetBA, lty = 2, col = "gray")
```
