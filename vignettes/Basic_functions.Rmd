---
title: "Basic functions and examples"
author: "Maxime Jaunatre"
package: matreex
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Basic functions and examples}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(cli.progress_show_after = 600) 
# 10 minutes before showing a cli progress bar
```

This vignette illustrate the basic pipeline used to run simulations with `{matreex}` package. The user can define different species of interest to combine and use in a simulation. During those simulations, modules can de triggered to test hypothesis and scenarii.

# Simulations input

## Define a species

Before simulating forest, we need first to define tree species in R. Species regroups basic dynamic functions : growth, recruitment and survival. To speed up computation, this package rely on **integrated projection models** (later named IPM). To explain this principle quickly, it is a matter of discretizing the dynamic functions into a kernel that allows us to go from a size distribution at time t to the distribution at time t+1. 

To build this IPM for a species, we start from the fitted functions. Theses functions depend on the size variable and climatic variables. The data provided with the package comes from [Kunstler *et al* (2020)](https://doi.org/10.1111/1365-2745.13533), and climatic variable are *sgdd* and *wai*. 

```{r hide library, echo = FALSE}
library(matreex)
data("fit_Picea_abies")
```

An IPM is mostly defined by it's mesh dimension, that are here $700 \times 700$ between 90mm and `get_maxdbh(fit_Picea_abies) * 1.1` = `r get_maxdbh(fit_Picea_abies) * 1.1`mm.

**Please keep in mind this computation is intensive and may take few minutes !**

```{r make IPM}
load_all()
# TODO library(matreex)
library(dplyr)
library(ggplot2)

# Load fitted model for a species
# fit_species # list of all species in dataset
data("fit_Picea_abies")

# Load associated climate
data("climate_species")
climate <- subset(climate_species, N == 2 & sp == "Picea_abies", select = -sp)
climate

Picea_ipm <- make_IPM(
    species = "Picea_abies", 
    climate = climate, 
    fit = fit_Picea_abies,
    clim_lab = "optimum clim",
    mesh = c(m = 700, L = 90, U = get_maxdbh(fit_Picea_abies) * 1.1),
    BA = 0:70, # Default values are 0:200, smaller values speed up this vignette.
    verbose = TRUE
)
```

Once the IPM is integrated on a BA range, we can use it to build a species upon it. This species will require few more function to works during simulations :

* `init_pop` : Function to draw the initial size distribution. The default one draw distribution for a basal area (later named BA) of 1 with random functions. The package provide other function to draw random distribution at a selected BA (`def_initBA()`) or a given distribution (`def_init_k()`).

* `harvest_fun` : Function that cut tree given the size distribution. The default function cut 0.6% of the trees regardless of their size at constant rate. Further functions allow to harvest according to Uneven and Even rules.

* `disturb_fun` : Function that return tree mortality after a disturbance. The default one does not react to disturbance.

A species also comes few parameters, but they are only used for harvest and disturbance modules.

For this example, we will just modify the initial size distribution to start at a reasonable basal area.

```{r species}
Picea_sp <- species(IPM = Picea_ipm, init_pop = def_initBA(30))
```

## Define a forest

Once each species is set, we can assemble them in a `forest` object. This scale also require to give additional parameters, but they are only used for harvest and disturbance modules.

```{r forest}
Picea_for <- forest(species = list(Picea = Picea_sp))
```

# Running simulations

Simulations will run until a given time limit is reached and can continue further if an equilibrium is not reached. Another parameters is the used surface `SurfEch`, and it's define the surface of the studied forest. This parameter is mainly here for historical purpose as models were fitted on $300m^2$ plot, and output is scaled to an hectare.

To explain the time limit, below we simulate for 200 years and past this time we continue the simulation until we reach an equilibrium on the last 50 years. This search for equilibrium will run until the 300th year. If we want to register the full dynamic, we can set `tlim = equil_time` with `equil_dist < tlim`. **The equilibrium is always the last size distribution**, and the simulation will detect it if the total variation of the BA on `equil_dist` is inferior to 1 (parameter `equil_diff`).

```{r sp1sim}
set.seed(42) # The seed is here for initial population random functions.
Picea_sim <- sim_deter_forest(
    Picea_for, 
    tlim = 200, 
    equil_time = 300, equil_dist = 50,
    SurfEch = 0.03,
    verbose = TRUE
)
```

The output of a simulation is a data.frame in long format (according to tidyverse style). This is very helpful to filter the output and plot it with `{ggplot2}`.

```{r sp1plot}
Picea_sim  %>%
    dplyr::filter(var %in% c("BAsp", "H"), ! equil) %>%
    ggplot2::ggplot(aes(x = time, y = value)) +
    ggplot2::facet_wrap(~ var, scales = "free_y") +
    ggplot2::geom_line(size = .4)
```

If size distributions needs to be extracted, it can be easily done with `{dplyr}` functions. The equilibrium step is associated with a logical to extract it.

```{r sp1head}
head(Picea_sim)
# get the maximum time
max_t <- max(Picea_sim$time)
# Filter example to extract the size distribution
Picea_sim %>% 
    dplyr::filter(grepl("m", var), time == max_t) %>% 
    select(size, value)
```

